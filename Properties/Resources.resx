<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="main_footer_version" xml:space="preserve">
    <value>Version</value>
  </data>
  <data name="main_hdr_connected" xml:space="preserve">
    <value>Connected</value>
  </data>
  <data name="main_hdr_disconnected" xml:space="preserve">
    <value>Disconnected</value>
  </data>
  <data name="main_hdr_PhotoApplication" xml:space="preserve">
    <value>Photo Image Uploader Application</value>
  </data>
  <data name="main_img_deleting" xml:space="preserve">
    <value>Deleting Images</value>
  </data>
  <data name="main_img_Fetching" xml:space="preserve">
    <value>Fetching Images</value>
  </data>
  <data name="main_img_uploading" xml:space="preserve">
    <value>Uploading Images</value>
  </data>
  <data name="main_msg_AllUploadSuccess" xml:space="preserve">
    <value>All images are uploaded succesfully.</value>
  </data>
  <data name="main_msg_ConnectionEstablished" xml:space="preserve">
    <value>Internet connection is established</value>
  </data>
  <data name="main_msg_connectionlost" xml:space="preserve">
    <value>Internet connection is lost.</value>
  </data>
  <data name="main_msg_imagenoexist" xml:space="preserve">
    <value>Image(s) in C:\\PhotoImages folder does not exist in the camera of the connected Photo, therefore cannot be deleted.</value>
  </data>
  <data name="main_msg_noImage" xml:space="preserve">
    <value>There are no images in the camera storage.</value>
  </data>
  <data name="main_msg_plugandunplug" xml:space="preserve">
    <value>Please unplug and plug the camera to start the process.</value>
  </data>
  <data name="main_msg_PhotoConnected" xml:space="preserve">
    <value>Photo is connected</value>
  </data>
  <data name="main_msg_PhotoNotConnected" xml:space="preserve">
    <value>Photo is not connected</value>
  </data>
  <data name="main_text_help" xml:space="preserve">
    <value>The first thing that needs paying attention is the status, Disconnected and Connected. By following the changes between these two statuses, you can understand the current situation of the process.
There are 3 steps in the application: 

-        Fetching the images from camera

-        Uploading the fetched ones to FTP server

-        Deleting the images from the camera


Note that, if there is another device connected to your computer, Photo Uploader Application may have trouble on working. Please make sure that Photo is the only device connected to your computer while working. Camera needs to be plugged in for application to fetch the images. Until that moment, the icon for fetching process will remain as “waiting”. If camera is switched off or plugged out, fetching functionality will not be working until camera is plugged in again. For this case, “waiting” icon will be displayed. After all the images are fetched, related icon will turn to “tick” and process will be successful. 

After fetching is done, application starts uploading process. Until that moment, “waiting” icon is placed for uploading process. In this section, it is important have a valid internet connection. It is not important for uploading process if camera is plugged in as long as there are already fetched images in the folder. You will be notified by turning the icon to successful tick when all the images are uploaded to FTP server.
Yet, camera must be plugged in for deleting process. After all images are deleted, you will be notified like the other processes, turning the icon to a successful tick. Until the deleting process is active, you will see a “waiting” icon for the process. If there’s an image that can not be deleted for any reason, application will show a message accordingly.

If another Photo is connected, then the application will stop processing. It is needed to restart the application in order to proceed.
When any of the processes are active/running, the number of processed elements and total count will be displayed within a “busy” icon.
When all the processes are done successfully, you will be notified with a message like “All images are uploaded successfully.”</value>
  </data>
  <data name="main_lbl_help" xml:space="preserve">
    <value>Help</value>
  </data>
</root>